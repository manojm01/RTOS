/*****************************************************************************
 *   rtc.c:  
*****************************************************************************/
#include "config.h"                       

#if RTC_EN
/*****************************************************************************
** 函数名:	
**
** 功能描述:	实时始终中断处理,处理闹铃的设置
** 
*****************************************************************************/
#if RTC_INTERRUPT_FLAG

void Rtc_Exception (void)
{  

    OS_ENTER_CRITICAL();	       /*  */ 
    ILR |= ILR_RTCCIF;		/* 清中断 */
	OS_EXIT_CRITICAL();	   
	/*Add your code here*/
      
}
#endif

/*****************************************************************************
** 函数名:		RTCInit
**
** 函数功能:	初始化实时时钟
**
** 
*****************************************************************************/
void RTCInit( void )
{
	/* 设置实时时钟 */
    CCR =0x00;
	/*
	 CLKEN  时钟使能。当该位为1 时，时间计数器使能。为0 时，时间计数器都被禁止， 
	        这时可对其进行初始化。 
	CTCRST  CTC 复位。为1 时，时钟节拍计数器复位。在CCR[1]变为0 之前，它将一直保持复位状态。
	CLKSRC  如果该位为0，时钟节拍计数器计数预分频器的时钟，这与早先的Philips 嵌入式ARM
	系列器件相吻合。如果该位为1，CTC 计数连接在RTCX1 和RTCX2
    两端的32kHz 振荡器信号（关于硬件的详细内容请见 
	*/
    PREINT = Fpclk / 32768 - 1;
    PREFRAC = Fpclk - (Fpclk / 32768) * 32768;
    YEAR = 2007;
    MONTH = 4;
    DOM = 25;
	/*interrupt Setting */
	#if RTC_INTERRUPT_FLAG
	ILR  = (0<<0)|(0<<1)  ;

	/*
	  RTCCIF 为1 时，计数器增量中断模块产生中断。向该位写入1 清除计数器增量中断。 
	  RTCALF 为1 时，报警寄存器产生中断。向该位写入1 清除报警中断。 
	*/ 
	CIIR =  0x00;
	/*
	0 IMSEC 为1 时，秒值的增加产生一次中断。 
    1 IMMIN 为1 时，分值的增加产生一次中断。 
    2 IMHOUR 为1 时，小时值的增加产生一次中断。	 
    3 IMDOM 为1 时，日期（月）值的增加产生一次中断。 
    4 IMDOW 为1 时，星期值的增加产生一次中断。 
    5 IMDOY 为1 时，日期（年）值的增加产生一次中断。 
    6 IMMON 为1 时，月值的增加产生一次中断。 
    7 IMYEAR 为1 时，年值的增加产生一次中断。 
	*/

	AMR  =  0x00;
	/*
	 0 AMRSEC 为1 时，秒值不与报警寄存器比较。 
	 1 AMRMIN 为1 时，分值不与报警寄存器比较。 
	 2 AMRHOUR 为1 时，小时值不与报警寄存器比较。 
	 3 AMRDOM 为1 时，日期（月）值不与报警寄存器比较。 
	 4 AMRDOW 为1 时，星期值不与报警寄存器比较。 		 				
	 5 AMRDOY 为1 时，日期（年）值不与报警寄存器比较。 
	 6 AMRMON 为1 时，月值不与报警寄存器比较。 
	 7 AMRYEAR 为1 时，年值不与报警寄存器比较。 
	*/
	#endif

}

/*****************************************************************************
** 函数名:		RTCStart
**
** 函数功能:    开启实时时钟 
**
** 
*****************************************************************************/
void RTCStart( void ) 
{
    CCR = 0x01;
	/*
	 CLKEN  时钟使能。当该位为1 时，时间计数器使能。为0 时，时间计数器都被禁止， 
	        这时可对其进行初始化。 
	CTCRST  CTC 复位。为1 时，时钟节拍计数器复位。在CCR[1]变为0 之前，它将一直保持复位状态。
	CLKSRC  如果该位为0，时钟节拍计数器计数预分频器的时钟，这与早先的Philips 嵌入式ARM
	系列器件相吻合。如果该位为1，CTC 计数连接在RTCX1 和RTCX2
    两端的32kHz 振荡器信号（关于硬件的详细内容请见 
	*/
}

/*****************************************************************************
** 函数名:		RTCStop
**
** 函数功能:	停止始终 
**
*****************************************************************************/
void RTCStop( void )
{   
    CCR &= 0xfe;
	/*
	 CLKEN  时钟使能。当该位为1 时，时间计数器使能。为0 时，时间计数器都被禁止， 
	        这时可对其进行初始化。 
	CTCRST  CTC 复位。为1 时，时钟节拍计数器复位。在CCR[1]变为0 之前，它将一直保持复位状态。
	CLKSRC  如果该位为0，时钟节拍计数器计数预分频器的时钟，这与早先的Philips 嵌入式ARM
	系列器件相吻合。如果该位为1，CTC 计数连接在RTCX1 和RTCX2
    两端的32kHz 振荡器信号（关于硬件的详细内容请见 
	*/
} 

/*****************************************************************************
** 函数名:		RTC_CTCReset
**
** 功能:		重启时钟计数器 
**
** 
*****************************************************************************/
void RTC_CTCReset( void )
{   
    CCR |= 0x02;
	/*
	 CLKEN  时钟使能。当该位为1 时，时间计数器使能。为0 时，时间计数器都被禁止， 
	        这时可对其进行初始化。 
	CTCRST  CTC 复位。为1 时，时钟节拍计数器复位。在CCR[1]变为0 之前，它将一直保持复位状态。
	CLKSRC  如果该位为0，时钟节拍计数器计数预分频器的时钟，这与早先的Philips 嵌入式ARM
	系列器件相吻合。如果该位为1，CTC 计数连接在RTCX1 和RTCX2
    两端的32kHz 振荡器信号（关于硬件的详细内容请见 
	*/
}

/*****************************************************************************
**函数名:		RTCSetTime
**
** 功能描述:	设置时钟的初始值 
**
** 
*****************************************************************************/
void RTCSetTime( RTCTime Time ) 
{
    SEC = Time.RTC_Sec;		 /*SEC 6 秒值的范围为0~59。 */
    MIN = Time.RTC_Min;		 /*MIN 6 分值的范围为0~59。 */
    HOUR = Time.RTC_Hour;	 /*HOUR 5 小时值的范围为0~23。 */
    DOM = Time.RTC_Mday;	 /*DOM 5日期（月）值的范围为1~28,29,30 或31（取决于月份以及是否为闰年）。[1] */
    DOW = Time.RTC_Wday;	 /*星期值的范围为0~6。[1] */
    DOY = Time.RTC_Yday;	 /*日期（年）值的范围为1~365（闰年为366） */
    MONTH = Time.RTC_Mon;	 /*MONTH 4 月值的范围为1~12。 */
    YEAR = Time.RTC_Year;    /*YEAR 12 年值的范围为0~4095 */
}

/*****************************************************************************
** 函数名:		RTCSetAlarm
**
** 功能描述:		初始华闹铃 
**
** 
*****************************************************************************/
void RTCSetAlarm( RTCTime Alarm ) 
{   
    ALSEC = Alarm.RTC_Sec;	    /* ALSEC 6 秒报警值 */
    ALMIN = Alarm.RTC_Min;		/* ALMIN 6 分报警值 */
    ALHOUR = Alarm.RTC_Hour;	/* ALHOUR 5 小时报警值 */
    ALDOM = Alarm.RTC_Mday;		/* ALDOM 5 日期（月）报警值 */
    ALDOW = Alarm.RTC_Wday;		/* ALDOW 3 星期报警值 */
    ALDOY = Alarm.RTC_Yday;		/* ALDOY 9 日期（年）报警值 */
    ALMON = Alarm.RTC_Mon;		/* ALMON 4 月报警值 */
    ALYEAR = Alarm.RTC_Year;    /* ALYEAR 12 年报警值 */
}

/*****************************************************************************
**函数名:		RTCGetTime
**
**功能描述:		获得时钟的当前值
**
** Returned value:	时钟参数结构体
** 
*****************************************************************************/
RTCTime RTCGetTime( void ) 
{
    RTCTime LocalTime;
    LocalTime.RTC_Sec = SEC;
    LocalTime.RTC_Min = MIN;
    LocalTime.RTC_Hour = HOUR;
    LocalTime.RTC_Mday = DOM;
    LocalTime.RTC_Wday = DOW;
    LocalTime.RTC_Yday = DOY;
    LocalTime.RTC_Mon = MONTH;
    LocalTime.RTC_Year = YEAR;
    return LocalTime;    
}

/*****************************************************************************
** 函数名:		RTCSetAlarmMask
**
** 功能描述:		闹钟屏蔽 
**
** 
*****************************************************************************/
void RTCSetAlarmMask( uint32 AlarmMask ) 
{ 
    AMR = 0x00;
		/*
	 0 AMRSEC 为1 时，秒值不与报警寄存器比较。 
	 1 AMRMIN 为1 时，分值不与报警寄存器比较。 
	 2 AMRHOUR 为1 时，小时值不与报警寄存器比较。 
	 3 AMRDOM 为1 时，日期（月）值不与报警寄存器比较。 
	 4 AMRDOW 为1 时，星期值不与报警寄存器比较。 		 				
	 5 AMRDOY 为1 时，日期（年）值不与报警寄存器比较。 
	 6 AMRMON 为1 时，月值不与报警寄存器比较。 
	 7 AMRYEAR 为1 时，年值不与报警寄存器比较。 
	*/
}

#endif
/*****************************************************************************
**                            End Of File
******************************************************************************/

